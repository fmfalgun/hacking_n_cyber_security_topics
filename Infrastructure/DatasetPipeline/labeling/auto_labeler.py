#!/usr/bin/env python3
"""
Automatic PCAP Labeling System
===============================

Automatically labels packet captures with attack metadata for ML training.

Reads YAML metadata files generated by unified_capture.py and creates
labeled datasets suitable for supervised learning.

Features:
- Multi-protocol support (WiFi, BLE, Zigbee, LoRa)
- Attack type classification
- Time-based segmentation
- Feature extraction preparation
- Train/test/validation split

Usage:
    python3 auto_labeler.py --input-dir ../../Datasets/WiFi \
                           --output-dir ../../Datasets/WiFi/labeled

Author: Wireless Security Research
License: Educational Use Only
"""

import os
import sys
import argparse
import yaml
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional
from dataclasses import dataclass, asdict
import pyshark

# ============================================================================
# Label Schema
# ============================================================================

@dataclass
class PacketLabel:
    """Individual packet label"""
    timestamp: float
    packet_number: int
    protocol: str
    attack_type: str
    attack_category: str
    is_attack: bool
    label: str  # "benign" or specific attack name
    confidence: float = 1.0


@dataclass
class DatasetMetadata:
    """Dataset metadata"""
    dataset_name: str
    protocol: str
    total_packets: int
    attack_packets: int
    benign_packets: int
    attack_types: List[str]
    capture_start: str
    capture_end: str
    duration_seconds: float
    pcap_file: str
    label_file: str
    created_at: str


# Attack label mapping
ATTACK_LABELS = {
    "WiFi": {
        "deauth_attack": "wifi_dos_deauth",
        "disassoc_attack": "wifi_dos_disassoc",
        "beacon_flood": "wifi_dos_beacon_flood",
        "evil_twin": "wifi_mitm_evil_twin",
        "karma_attack": "wifi_mitm_karma",
        "packet_injection": "wifi_injection_packet"
    },
    "BLE": {
        "att_write_flood": "ble_dos_att_write",
        "advertising_flood": "ble_dos_adv_flood",
        "connection_flood": "ble_dos_conn_flood",
        "pairing_interception": "ble_mitm_pairing",
        "packet_crafting": "ble_injection_craft"
    },
    "Zigbee": {
        "rf_jamming": "zigbee_dos_rf_jam",
        "beacon_flood": "zigbee_dos_beacon",
        "malicious_coordinator": "zigbee_mitm_coordinator",
        "zcl_onoff_injection": "zigbee_injection_zcl"
    },
    "LoRa": {
        "join_request_flood": "lora_dos_join_flood",
        "uplink_flood": "lora_dos_uplink",
        "rogue_gateway": "lora_mitm_rogue_gw",
        "malicious_uplink": "lora_injection_uplink"
    }
}

# ============================================================================
# Auto Labeler
# ============================================================================

class AutoLabeler:
    """Automatic PCAP labeling system"""

    def __init__(self, input_dir: str, output_dir: str):
        self.input_dir = Path(input_dir)
        self.output_dir = Path(output_dir)
        self.labels = []
        self.metadata = None

    def find_pcap_files(self) -> List[Path]:
        """Find all PCAP files with corresponding YAML metadata"""
        pcap_files = []

        for pcap_file in self.input_dir.glob("*.pcap"):
            yaml_file = pcap_file.with_suffix('.yaml')
            if yaml_file.exists():
                pcap_files.append(pcap_file)
                print(f"[+] Found: {pcap_file.name} (with metadata)")
            else:
                print(f"[!] Skipping: {pcap_file.name} (no metadata)")

        return pcap_files

    def load_metadata(self, yaml_file: Path) -> Dict:
        """Load capture metadata from YAML"""
        with open(yaml_file, 'r') as f:
            metadata = yaml.safe_load(f)
        return metadata

    def label_pcap(self, pcap_file: Path, metadata: Dict) -> List[PacketLabel]:
        """
        Label packets in PCAP file

        Strategy:
        1. All packets during attack window = attack label
        2. Can extend with heuristics (packet type, rate, etc.)
        """
        labels = []

        protocol = metadata.get('protocol')
        attack_type = metadata.get('attack_type')
        attack_category = metadata.get('attack_category')

        # Get attack label
        attack_label = ATTACK_LABELS.get(protocol, {}).get(attack_type, f"{protocol}_{attack_type}")

        print(f"\n[*] Labeling: {pcap_file.name}")
        print(f"    Protocol: {protocol}")
        print(f"    Attack: {attack_type}")
        print(f"    Label: {attack_label}")

        try:
            # Parse PCAP with pyshark
            cap = pyshark.FileCapture(
                str(pcap_file),
                keep_packets=False  # Memory efficient
            )

            packet_count = 0
            for pkt in cap:
                packet_count += 1

                # Extract timestamp
                try:
                    timestamp = float(pkt.sniff_timestamp)
                except:
                    timestamp = packet_count * 0.001  # Fallback

                # Create label
                label = PacketLabel(
                    timestamp=timestamp,
                    packet_number=packet_count,
                    protocol=protocol,
                    attack_type=attack_type,
                    attack_category=attack_category,
                    is_attack=True,  # All packets in attack PCAP are attack packets
                    label=attack_label,
                    confidence=1.0
                )

                labels.append(label)

                # Progress
                if packet_count % 1000 == 0:
                    print(f"\r    Labeled: {packet_count} packets", end='', flush=True)

            cap.close()
            print(f"\r    Labeled: {packet_count} packets - Complete")

        except Exception as e:
            print(f"\n[!] Error parsing PCAP: {e}")
            return []

        return labels

    def save_labels(self, labels: List[PacketLabel], output_file: Path):
        """Save labels to JSON file"""
        print(f"[*] Saving labels: {output_file}")

        # Convert to dict
        labels_dict = [asdict(label) for label in labels]

        # Save
        with open(output_file, 'w') as f:
            json.dump(labels_dict, f, indent=2)

        print(f"[+] Saved {len(labels)} labels")

    def create_dataset_metadata(self, pcap_file: Path, labels: List[PacketLabel],
                                capture_metadata: Dict) -> DatasetMetadata:
        """Create dataset metadata summary"""

        attack_packets = sum(1 for l in labels if l.is_attack)
        benign_packets = len(labels) - attack_packets

        attack_types = list(set(l.label for l in labels))

        metadata = DatasetMetadata(
            dataset_name=pcap_file.stem,
            protocol=capture_metadata.get('protocol'),
            total_packets=len(labels),
            attack_packets=attack_packets,
            benign_packets=benign_packets,
            attack_types=attack_types,
            capture_start=capture_metadata.get('start_time', ''),
            capture_end=capture_metadata.get('end_time', ''),
            duration_seconds=capture_metadata.get('duration_seconds', 0),
            pcap_file=str(pcap_file),
            label_file=str(pcap_file.with_suffix('.labels.json')),
            created_at=datetime.now().isoformat()
        )

        return metadata

    def process_pcap(self, pcap_file: Path):
        """Process single PCAP file"""
        yaml_file = pcap_file.with_suffix('.yaml')

        # Load metadata
        capture_metadata = self.load_metadata(yaml_file)

        # Label packets
        labels = self.label_pcap(pcap_file, capture_metadata)

        if not labels:
            print(f"[!] No labels generated for {pcap_file.name}")
            return

        # Output files
        self.output_dir.mkdir(parents=True, exist_ok=True)
        output_label_file = self.output_dir / f"{pcap_file.stem}.labels.json"
        output_metadata_file = self.output_dir / f"{pcap_file.stem}.metadata.json"

        # Save labels
        self.save_labels(labels, output_label_file)

        # Create and save dataset metadata
        dataset_metadata = self.create_dataset_metadata(pcap_file, labels, capture_metadata)
        with open(output_metadata_file, 'w') as f:
            json.dump(asdict(dataset_metadata), f, indent=2)

        print(f"[+] Dataset metadata: {output_metadata_file}")

        # Statistics
        print(f"\n[*] Statistics:")
        print(f"    Total packets:  {len(labels)}")
        print(f"    Attack packets: {dataset_metadata.attack_packets}")
        print(f"    Benign packets: {dataset_metadata.benign_packets}")
        print(f"    Attack types:   {', '.join(dataset_metadata.attack_types)}")

    def run(self):
        """Process all PCAP files"""
        print("="*70)
        print("  Automatic PCAP Labeling System")
        print("="*70)
        print(f"Input directory:  {self.input_dir}")
        print(f"Output directory: {self.output_dir}")
        print("="*70 + "\n")

        # Find PCAP files
        pcap_files = self.find_pcap_files()

        if not pcap_files:
            print("[!] No PCAP files with metadata found")
            return 1

        print(f"\n[*] Found {len(pcap_files)} PCAP file(s) to process\n")

        # Process each
        for i, pcap_file in enumerate(pcap_files, 1):
            print(f"\n{'='*70}")
            print(f"Processing {i}/{len(pcap_files)}: {pcap_file.name}")
            print('='*70)

            try:
                self.process_pcap(pcap_file)
            except Exception as e:
                print(f"\n[!] Error processing {pcap_file.name}: {e}")
                continue

        print("\n" + "="*70)
        print("  Labeling Complete")
        print("="*70)
        print(f"Processed: {len(pcap_files)} files")
        print(f"Output: {self.output_dir}")
        print("="*70 + "\n")

        return 0


# ============================================================================
# CLI
# ============================================================================

def parse_arguments() -> argparse.Namespace:
    """Parse command-line arguments"""
    parser = argparse.ArgumentParser(
        description="Automatic PCAP Labeling System",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('--input-dir', required=True,
                       help='Input directory with PCAP and YAML files')
    parser.add_argument('--output-dir', required=True,
                       help='Output directory for labeled data')
    parser.add_argument('--protocol',
                       choices=['WiFi', 'BLE', 'Zigbee', 'LoRa'],
                       help='Filter by protocol')

    return parser.parse_args()


def main() -> int:
    """Main entry point"""
    args = parse_arguments()

    labeler = AutoLabeler(args.input_dir, args.output_dir)
    return labeler.run()


if __name__ == '__main__':
    sys.exit(main())
